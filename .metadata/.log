!SESSION 2023-05-12 11:10:57.581 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.7
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_MX
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -data C:\generation\java\ch26-java -product org.eclipse.epp.package.jee.product

!ENTRY ch.qos.logback.classic 1 0 2023-05-12 11:10:58.629
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-05-12 11:10:59.543
!MESSAGE Logback config file: C:\generation\java\ch26-java\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.100.20230106-1511.xml

!ENTRY org.eclipse.jface 2 0 2023-05-12 11:11:01.579
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-12 11:11:01.580
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-12 11:11:05.635
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sofia'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-05-12 11:19:29.883
!MESSAGE Classpath changed for project: java03-tiposdatos

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-05-12 11:24:54.635
!MESSAGE DelegatingStreamConnectionProvider - Starting Boot LS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-05-12 11:24:54.640
!MESSAGE Started org.springframework.tooling.boot.ls LS process 17356

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:14.374
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            					(numEmpleados > 0 && < 2000));
            					System.out.println("Empleados > 0 && Empleados < 2000  " + 
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:54:14.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:54:14.375
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:14.380
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            					(numEmpleados > 0 && < 2000));
            					System.out.println("Empleados > 0 && Empleados < 2000  " + 
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:14.381
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:14.382
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:37.303
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:54:37.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:54:37.304
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:37.404
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:37.406
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:37.406
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:39.764
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:39.765
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:39.765
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:55.608
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
            
           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:55.609
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:55.609
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:56.931
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
					System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:54:56.932
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:54:56.932
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:57.060
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
					System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:57.061
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:57.061
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:58.530
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
					System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:58.531
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:58.531
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:54:59.000
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
					System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:54:59.000
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:54:59.001
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:04.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
					System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:04.345
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:04.345
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:05.574
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:05.574
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:05.574
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:05.733
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:05.734
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:05.734
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:11.464
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 200: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:11.465
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:11.465
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:12.542
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:12.542
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:12.542
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:12.669
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:12.670
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:12.671
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:19.278
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:19.279
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:19.279
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:21.639
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:21.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:21.640
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:22.436
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:22.437
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:22.437
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:24.840
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
            //System.out.println("Empleados > 0 && Empleados < 2000  " + 
					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:24.840
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:24.841
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:27.248
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:27.248
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:27.249
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:27.253
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:27.254
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:27.255
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:31.311
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            System.out.println("Empleados > 0 && Empleados < 2000  " + 
            					(numEmpleados > 0 && < 2000));
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:31.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:31.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:33.165
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:33.166
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:33.166
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:33.358
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
            
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:33.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:33.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:34.085
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:34.086
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:34.086
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:34.233
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:34.233
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:34.234
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:37.059
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:37.060
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:37.060
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:37.152
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:37.153
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:37.153
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:52.123
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:52.124
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:52.124
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:52.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			//System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:52.217
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:52.217
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:52.732
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			// System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-12 16:55:52.733
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-12 16:55:52.733
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-12 16:55:54.046
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package org.generation;

public class Variables {

	public static void main(String[] args) {
		/*
		 * Reglas para el nombre de las variables:
		 * - Se distingue entre minúsculas y mayúsculas
		 * - La longitud del nombre es ilimitada
		 * - Puedes utilizar cualquier caracter Unicode (evitar letra ñ)
		 * - La variable puede comenzar:
		 *   > una letra ej. miVariable
		 *   > signo de dolar $miVariable (no recomendado)
		 *   > caracter de subrayado _miVariable (no recomendado)
		 */
		
		int $myVar; // es válido, pero no se recomienda
		int _myVar; // es válido, pero no se recomienda
		//int #myVar; // no es válido
		int myVarEspañol; // es válido pero de preferencia nombres en inglés 
		int sinC0m3nt4rios; // es válido
		
		/*
		 * En Java tendremos los siguientes tipos de variables:
		 *  Variables de instancia (Non static fields):atributos de los objetos
		 *  Variables de clase (Static Fields): atributos de la clase
		 *  Variables locales (local variables): variable dentro de las funciones(métodos)
		 *  Parámetros (parameters): Entrada de las funciones
		 */
          
		/* Tipos de datos en Java
		 * - Objetos
		 * - Datos primitivos
		 * 		 8 datos primitivos
		 * >byte
		 * >shorte
		 * >int
		 * >long
		 * >float
		 * >double
		 * >boolean
		 * >char
		 * 
		 */
		
		// el tipo byte es de 8 bits, almacena datos numéricos enteros
			byte myVarByte = 12;
			System.out.println("byte: " + myVarByte);
		// 2^8 = 256 
		// Obtener el valor máximo y mínimo del tipo byte, usando su
		// wrapper (Clase envolvente) Byte.
			System.out.println("Byte, Max value: " + Byte.MAX_VALUE );
			System.out.println("Byte, Max value: " + Byte.MIN_VALUE );

			
		// El tipo short es de 16 bits, almacena datos numéricos enteros.
		// 2^16 = 65536
			short myVarShort = 500;
			System.out.println("short: " + myVarShort);
			System.out.println("Byte, Max value: " + Short.MAX_VALUE );
			System.out.println("Byte, Max value: " + Short.MIN_VALUE );
		// El tipo int es de 32 bits, almacena datos numéricos enteros.
		// 2^32 = 2147483647
			int myVarInt = 1000;
			System.out.println("int: " + myVarInt);
			// El wrapper para int -> Integer
			System.out.println("Integer, Max value: " + Integer.MAX_VALUE );
			System.out.println("Integer, Max value: " + Integer.MIN_VALUE );
			
		// El tipo long es de 64 bits, almacena datos numéricos enteros.
		// 2^64
			long myVarLong = 1500;
			System.out.println("long " + myVarLong);
			System.out.println("Long, Max value: " + Long.MAX_VALUE );
			System.out.println("Long, Max value: " + Long.MIN_VALUE );
		//----------------------------------------------------------
		// El tipo float es de 32 bits, almacena datos numéricos de punto flotante (real).
			float myVarFloat = 1500.6523F;
			System.out.println("float: " + myVarFloat);
			System.out.println("Float, Max value: " + Float.MAX_VALUE );
			System.out.println("Float, Max value: " + Float.MIN_VALUE );
			
		// Las literales numéricas enteras son de tipo int.
		// Las literales numéricas de punto flotante son de tipo double
		// Para indicar una literal numérica de tipo long, hay que indicar
		// la literak con la letra L.
			long myLiteralLong = 2147483648L;
		// Para indicar una literal numérica de tipo float, hay que indicar 
		// la literal con la letra F.
			
		// El tipo double es de 64 bits, almacena datos de punto flotante.
			double myVarDouble = 1500.6523F;
			System.out.println("double: " + myVarFloat);
			System.out.println("Double, Max value: " + Double.MAX_VALUE );
			System.out.println("Double, Max value: " + Double.MIN_VALUE );
			
        //-----------------------------------------------
		
		// El tipo boolean solo almacena valores true o false
			boolean myVarBoolean = true;
			
		// El tipo char solo almacena un caracter, se debe definir la literal
		// entre apostrofe ej. 'a'. Solo almacena caracteres de la tabla unicode(16 bits)
		// puede almacenar del 0 al 65535.
			
			char losPandillerosDeLaTarde = 'I';
            System.out.println("char: " + losPandillerosDeLaTarde);
        // Podemos definir un char por su código unicode o su valor numérico.
           char letraL = '\u004C'; // L
           System.out.println("La letra L:" + letraL);
           char letraM = 77; // M
           System.out.println("La letra M: " + letraM);
 		
         // ------------------------------------------------
         // Formas de representar un número
         // Representación decimal
           System.out.println("Representación decimal: " + 26);
           System.out.println("Representación hexadecimal: " + 0x1a);
           System.out.println("Representación binaria: " + 0b11010);
         // Para las literales numéricas se puede usar el guión bajo_ para separar números
         // No se puede escribir _ al inicio o final de la literal
         // No se puede escribir _ junto a un punto decimal
         // No se puede escribir _  antes de la F o L
            int numeroSeparados = 12_345;
            float numerosFloatSeparados= 12_345.456_346F;
            
         //-----------------------------------------------------------------
         // Conversión de tipos de datos
            byte coquita600ml = 60;
            // upcasting
            short coquita2000ml = coquita600ml;  
            // downcasting
            short pozoleGrande1L = 259;
            byte pozoleBurbuja = (byte) pozoleGrande1L;
            System.out.println("Pozole burbuja: " + pozoleBurbuja);
            
         // ------------------------------------------------------------------
         // Objetos de tipo String.
         // Se definen entre comillas dobles.
         // Si deseas imprimir comillas dobles en el mensaje, se usa el caracter de escape \
            String myVarString = "Holi \"Milo\"";
            System.out.println("Mensaje string: " + myVarString);
         
            
         // Convertir de string a números 
            byte edadMascota = Byte.parseByte("10");
            double edadPlaneta = Double.parseDouble("456.8956");
            System.out.println(edadMascota + " , " + edadPlaneta);
         // Convertir números a String
            String edadString = String.valueOf( 4568 );
         // Obteniendo la longitud de un String
            System.out.println("El número de digitos en edadString = " + edadString.length());
         // Obteniendo el primer caracter de un String.
            System.out.println("El primer caracter de " + edadString + " es: " + edadString.charAt(0));
            System.out.println("El segundo caracter de " + edadString + " es: " + edadString.charAt(1));
            
         //-------------------------------------------------------------------------
         // Operadores numéricos
            int opA = (int) 5.2;
            int opB = 6;
            int suma = opA + opB;
            int resta = opA - opB;
            int multiplica = (int) (opA * opB * 1.01);
            double multiplicaDouble = opA * opB * 1.01;
            int division = opA/opB;
            double divisionDouble = 1.0 * opA / opB;
            int residuo = opA % 2;
            
            System.out.println(suma);
            System.out.println(resta);
            System.out.println(multiplica);
            System.out.println(multiplicaDouble);
            System.out.println((0.1 * 1000 +0.2* 1000)/1000);
            System.out.println(division);
            System.out.println(divisionDouble);
            System.out.println("Residuo de 5%6= " + residuo);
            
            int valorInicial = 10;
            System.out.println("Preincremento " + ++valorInicial); // 11
            System.out.println("Postincremento " + valorInicial++); // 11
            System.out.println("Valor final " + valorInicial); // 12
            valorInicial = 33;
            System.out.println("Predecremento " + --valorInicial); // 32
            System.out.println("Postdecremento " + valorInicial--); // 32
            System.out.println("Valor final " + valorInicial);//31
            
            // Operaciones con valores enteros
            byte edadGato = 10;
            short dobleDeEdad = (short) (edadGato * 2);
            
            // Operadores comparativos
            // <, <=, >, >=, ==, !=
            int numEmpleados = 1000;
            System.out.println("Empleados > 1000 " + (numEmpleados > 1000));
            System.out.println("Empleados >= 1000 " + (numEmpleados >= 1000));
            System.out.println("Empleados == 1000 " + (numEmpleados == 1000));
            System.out.println("Empleados != 1000 " + (numEmpleados != 1000));
            
            // Operadores lógicos
            // && (AND) retorna true si ambos operadores son true
            // || (OR) retorna true si cualquiera de los operandos es true
            // ! (NOT) invierte el resultado booleano
            
           
			System.out.println("Empleados > 0 && Empleados < 2000: " +
				             (numEmpleados > 0 && numEmpleados < 2000));
			// System.out.println("Empleados > 0 && Empleados < 2000  " + 
			(numEmpleados > 0 && < 2000));

           
            
            
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-12 16:55:54.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-12 16:55:54.047
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-05-12 17:13:28.761
!MESSAGE Classpath changed for project: java03-tiposdatos

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-05-12 17:14:18.733
!MESSAGE Classpath changed for project: java05-flujo-control

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-05-12 17:24:02.519
!MESSAGE Classpath changed for project: java05-flujo-control
